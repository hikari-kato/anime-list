"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/jikan-api.ts":
/*!******************************!*\
  !*** ./src/lib/jikan-api.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnimeById: () => (/* binding */ getAnimeById),\n/* harmony export */   getAnimeExternalLinks: () => (/* binding */ getAnimeExternalLinks),\n/* harmony export */   getCurrentSeasonAnime: () => (/* binding */ getCurrentSeasonAnime),\n/* harmony export */   sortAnimeByBroadcastDay: () => (/* binding */ sortAnimeByBroadcastDay)\n/* harmony export */ });\nconst JIKAN_API_BASE_URL = 'https://api.jikan.moe/v4';\nasync function getCurrentSeasonAnime() {\n    try {\n        const allAnime = [];\n        let page = 1;\n        let hasNextPage = true;\n        while(hasNextPage && page <= 5){\n            var _data_pagination;\n            const response = await fetch(\"\".concat(JIKAN_API_BASE_URL, \"/seasons/now?page=\").concat(page));\n            if (!response.ok) {\n                break;\n            }\n            const data = await response.json();\n            if (!data || !Array.isArray(data.data)) {\n                break;\n            }\n            allAnime.push(...data.data.filter((anime)=>anime && anime.mal_id && anime.type !== 'OVA'));\n            hasNextPage = ((_data_pagination = data.pagination) === null || _data_pagination === void 0 ? void 0 : _data_pagination.has_next_page) || false;\n            page++;\n        }\n        return removeDuplicateAnime(allAnime);\n    } catch (e) {\n        return [];\n    }\n}\nfunction removeDuplicateAnime(animeList) {\n    const seenTitles = new Set();\n    const uniqueAnime = [];\n    for (const anime of animeList){\n        // 日本語タイトル、英語タイトル、通常タイトルの優先順で確認\n        const title = anime.title_japanese || anime.title || anime.title_english || '';\n        const normalizedTitle = title.toLowerCase().trim();\n        if (!seenTitles.has(normalizedTitle) && normalizedTitle) {\n            seenTitles.add(normalizedTitle);\n            uniqueAnime.push(anime);\n        }\n    }\n    return uniqueAnime;\n}\nasync function getAnimeById(id) {\n    try {\n        const response = await fetch(\"\".concat(JIKAN_API_BASE_URL, \"/anime/\").concat(id), {\n            cache: 'force-cache'\n        });\n        if (!response.ok) {\n            console.error(\"HTTP error fetching anime \".concat(id, \": \").concat(response.status));\n            return null;\n        }\n        const data = await response.json();\n        if (!data || !data.data) {\n            console.error(\"Invalid anime data received for ID \".concat(id));\n            return null;\n        }\n        return data.data;\n    } catch (error) {\n        console.error(\"Error fetching anime with ID \".concat(id, \":\"), error);\n        return null;\n    }\n}\nasync function getAnimeExternalLinks(animeId) {\n    try {\n        const response = await fetch(\"\".concat(JIKAN_API_BASE_URL, \"/anime/\").concat(animeId, \"/external\"), {\n            cache: 'force-cache'\n        });\n        if (!response.ok) {\n            return null;\n        }\n        const data = await response.json();\n        if (!data || !Array.isArray(data.data)) {\n            return null;\n        }\n        // \"Official Site\"を検索\n        const officialSite = data.data.find((link)=>link.name === 'Official Site' || link.name === 'Official Website' || link.name.toLowerCase().includes('official'));\n        return officialSite ? officialSite.url : null;\n    } catch (error) {\n        console.error(\"Error fetching external links for anime \".concat(animeId, \":\"), error);\n        return null;\n    }\n}\nfunction sortAnimeByBroadcastDay(animeList) {\n    const dayOrder = [\n        'monday',\n        'tuesday',\n        'wednesday',\n        'thursday',\n        'friday',\n        'saturday',\n        'sunday'\n    ];\n    return animeList.sort((a, b)=>{\n        var _a_broadcast_day, _a_broadcast, _b_broadcast_day, _b_broadcast, _a_type, _b_type;\n        const dayA = ((_a_broadcast = a.broadcast) === null || _a_broadcast === void 0 ? void 0 : (_a_broadcast_day = _a_broadcast.day) === null || _a_broadcast_day === void 0 ? void 0 : _a_broadcast_day.toLowerCase()) || 'unknown';\n        const dayB = ((_b_broadcast = b.broadcast) === null || _b_broadcast === void 0 ? void 0 : (_b_broadcast_day = _b_broadcast.day) === null || _b_broadcast_day === void 0 ? void 0 : _b_broadcast_day.toLowerCase()) || 'unknown';\n        const indexA = dayOrder.indexOf(dayA);\n        const indexB = dayOrder.indexOf(dayB);\n        if (indexA === -1 && indexB === -1) return 0;\n        if (indexA === -1) return 1;\n        if (indexB === -1) return -1;\n        if (indexA !== indexB) {\n            return indexA - indexB;\n        }\n        const typeA = ((_a_type = a.type) === null || _a_type === void 0 ? void 0 : _a_type.toLowerCase()) === 'tv' ? 0 : 1;\n        const typeB = ((_b_type = b.type) === null || _b_type === void 0 ? void 0 : _b_type.toLowerCase()) === 'tv' ? 0 : 1;\n        return typeA - typeB;\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvamlrYW4tYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQSxNQUFNQSxxQkFBcUI7QUFFcEIsZUFBZUM7SUFDcEIsSUFBSTtRQUNGLE1BQU1DLFdBQXdCLEVBQUU7UUFDaEMsSUFBSUMsT0FBTztRQUNYLElBQUlDLGNBQWM7UUFFbEIsTUFBT0EsZUFBZUQsUUFBUSxFQUFHO2dCQWNqQkU7WUFiZCxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBMENKLE9BQXZDSCxvQkFBbUIsc0JBQXlCLE9BQUxHO1lBRXZFLElBQUksQ0FBQ0csU0FBU0UsRUFBRSxFQUFFO2dCQUNoQjtZQUNGO1lBRUEsTUFBTUgsT0FBc0IsTUFBTUMsU0FBU0csSUFBSTtZQUUvQyxJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssTUFBTUMsT0FBTyxDQUFDTixLQUFLQSxJQUFJLEdBQUc7Z0JBQ3RDO1lBQ0Y7WUFFQUgsU0FBU1UsSUFBSSxJQUFJUCxLQUFLQSxJQUFJLENBQUNRLE1BQU0sQ0FBQ0MsQ0FBQUEsUUFBU0EsU0FBU0EsTUFBTUMsTUFBTSxJQUFJRCxNQUFNRSxJQUFJLEtBQUs7WUFDbkZaLGNBQWNDLEVBQUFBLG1CQUFBQSxLQUFLWSxVQUFVLGNBQWZaLHVDQUFBQSxpQkFBaUJhLGFBQWEsS0FBSTtZQUNoRGY7UUFDRjtRQUVBLE9BQU9nQixxQkFBcUJqQjtJQUM5QixFQUFFLFVBQU07UUFDTixPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsU0FBU2lCLHFCQUFxQkMsU0FBc0I7SUFDbEQsTUFBTUMsYUFBYSxJQUFJQztJQUN2QixNQUFNQyxjQUEyQixFQUFFO0lBRW5DLEtBQUssTUFBTVQsU0FBU00sVUFBVztRQUM3QiwrQkFBK0I7UUFDL0IsTUFBTUksUUFBUVYsTUFBTVcsY0FBYyxJQUFJWCxNQUFNVSxLQUFLLElBQUlWLE1BQU1ZLGFBQWEsSUFBSTtRQUM1RSxNQUFNQyxrQkFBa0JILE1BQU1JLFdBQVcsR0FBR0MsSUFBSTtRQUVo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QUFBQSxFQUFFakMsSUFBSSxjQUFOaUMsOEJBQUFBLFFBQVFyQixXQUFXLFFBQU8sT0FBTyxJQUFJO1FBQ25ELE1BQU0rQixRQUFRVCxFQUFBQSxVQUFBQSxFQUFFbEMsSUFBSSxjQUFOa0MsOEJBQUFBLFFBQVF0QixXQUFXLFFBQU8sT0FBTyxJQUFJO1FBRW5ELE9BQU84QixRQUFRQztJQUNqQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMva2F0by9Eb2N1bWVudHMvR2l0SHViL2FuaW1lLWxpc3Qvc3JjL2xpYi9qaWthbi1hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSmlrYW5SZXNwb25zZSwgQW5pbWVEYXRhIH0gZnJvbSAnQC90eXBlcy9hbmltZSc7XG5cbmNvbnN0IEpJS0FOX0FQSV9CQVNFX1VSTCA9ICdodHRwczovL2FwaS5qaWthbi5tb2UvdjQnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFNlYXNvbkFuaW1lKCk6IFByb21pc2U8QW5pbWVEYXRhW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhbGxBbmltZTogQW5pbWVEYXRhW10gPSBbXTtcbiAgICBsZXQgcGFnZSA9IDE7XG4gICAgbGV0IGhhc05leHRQYWdlID0gdHJ1ZTtcblxuICAgIHdoaWxlIChoYXNOZXh0UGFnZSAmJiBwYWdlIDw9IDUpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7SklLQU5fQVBJX0JBU0VfVVJMfS9zZWFzb25zL25vdz9wYWdlPSR7cGFnZX1gKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0YTogSmlrYW5SZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKCFkYXRhIHx8ICFBcnJheS5pc0FycmF5KGRhdGEuZGF0YSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGFsbEFuaW1lLnB1c2goLi4uZGF0YS5kYXRhLmZpbHRlcihhbmltZSA9PiBhbmltZSAmJiBhbmltZS5tYWxfaWQgJiYgYW5pbWUudHlwZSAhPT0gJ09WQScpKTtcbiAgICAgIGhhc05leHRQYWdlID0gZGF0YS5wYWdpbmF0aW9uPy5oYXNfbmV4dF9wYWdlIHx8IGZhbHNlO1xuICAgICAgcGFnZSsrO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVEdXBsaWNhdGVBbmltZShhbGxBbmltZSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVBbmltZShhbmltZUxpc3Q6IEFuaW1lRGF0YVtdKTogQW5pbWVEYXRhW10ge1xuICBjb25zdCBzZWVuVGl0bGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHVuaXF1ZUFuaW1lOiBBbmltZURhdGFbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgYW5pbWUgb2YgYW5pbWVMaXN0KSB7XG4gICAgLy8g5pel5pys6Kqe44K/44Kk44OI44Or44CB6Iux6Kqe44K/44Kk44OI44Or44CB6YCa5bi444K/44Kk44OI44Or44Gu5YSq5YWI6aCG44Gn56K66KqNXG4gICAgY29uc3QgdGl0bGUgPSBhbmltZS50aXRsZV9qYXBhbmVzZSB8fCBhbmltZS50aXRsZSB8fCBhbmltZS50aXRsZV9lbmdsaXNoIHx8ICcnO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaXRsZSA9IHRpdGxlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIFxuICAgIGlmICghc2VlblRpdGxlcy5oYXMobm9ybWFsaXplZFRpdGxlKSAmJiBub3JtYWxpemVkVGl0bGUpIHtcbiAgICAgIHNlZW5UaXRsZXMuYWRkKG5vcm1hbGl6ZWRUaXRsZSk7XG4gICAgICB1bmlxdWVBbmltZS5wdXNoKGFuaW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pcXVlQW5pbWU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmltZUJ5SWQoaWQ6IG51bWJlcik6IFByb21pc2U8QW5pbWVEYXRhIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7SklLQU5fQVBJX0JBU0VfVVJMfS9hbmltZS8ke2lkfWAsIHtcbiAgICAgIGNhY2hlOiAnZm9yY2UtY2FjaGUnLFxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEhUVFAgZXJyb3IgZmV0Y2hpbmcgYW5pbWUgJHtpZH06ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgYW5pbWUgZGF0YSByZWNlaXZlZCBmb3IgSUQgJHtpZH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGFuaW1lIHdpdGggSUQgJHtpZH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmltZUV4dGVybmFsTGlua3MoYW5pbWVJZDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtKSUtBTl9BUElfQkFTRV9VUkx9L2FuaW1lLyR7YW5pbWVJZH0vZXh0ZXJuYWxgLCB7XG4gICAgICBjYWNoZTogJ2ZvcmNlLWNhY2hlJyxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIFwiT2ZmaWNpYWwgU2l0ZVwi44KS5qSc57SiXG4gICAgY29uc3Qgb2ZmaWNpYWxTaXRlID0gZGF0YS5kYXRhLmZpbmQoKGxpbms6IGFueSkgPT4gXG4gICAgICBsaW5rLm5hbWUgPT09ICdPZmZpY2lhbCBTaXRlJyB8fCBcbiAgICAgIGxpbmsubmFtZSA9PT0gJ09mZmljaWFsIFdlYnNpdGUnIHx8XG4gICAgICBsaW5rLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnb2ZmaWNpYWwnKVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIG9mZmljaWFsU2l0ZSA/IG9mZmljaWFsU2l0ZS51cmwgOiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGV4dGVybmFsIGxpbmtzIGZvciBhbmltZSAke2FuaW1lSWR9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc29ydEFuaW1lQnlCcm9hZGNhc3REYXkoYW5pbWVMaXN0OiBBbmltZURhdGFbXSk6IEFuaW1lRGF0YVtdIHtcbiAgY29uc3QgZGF5T3JkZXIgPSBbJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5J107XG4gIFxuICByZXR1cm4gYW5pbWVMaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBkYXlBID0gYS5icm9hZGNhc3Q/LmRheT8udG9Mb3dlckNhc2UoKSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZGF5QiA9IGIuYnJvYWRjYXN0Py5kYXk/LnRvTG93ZXJDYXNlKCkgfHwgJ3Vua25vd24nO1xuICAgIFxuICAgIGNvbnN0IGluZGV4QSA9IGRheU9yZGVyLmluZGV4T2YoZGF5QSk7XG4gICAgY29uc3QgaW5kZXhCID0gZGF5T3JkZXIuaW5kZXhPZihkYXlCKTtcbiAgICBcbiAgICBpZiAoaW5kZXhBID09PSAtMSAmJiBpbmRleEIgPT09IC0xKSByZXR1cm4gMDtcbiAgICBpZiAoaW5kZXhBID09PSAtMSkgcmV0dXJuIDE7XG4gICAgaWYgKGluZGV4QiA9PT0gLTEpIHJldHVybiAtMTtcbiAgICBcbiAgICBpZiAoaW5kZXhBICE9PSBpbmRleEIpIHtcbiAgICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHR5cGVBID0gYS50eXBlPy50b0xvd2VyQ2FzZSgpID09PSAndHYnID8gMCA6IDE7XG4gICAgY29uc3QgdHlwZUIgPSBiLnR5cGU/LnRvTG93ZXJDYXNlKCkgPT09ICd0dicgPyAwIDogMTtcbiAgICBcbiAgICByZXR1cm4gdHlwZUEgLSB0eXBlQjtcbiAgfSk7XG59Il0sIm5hbWVzIjpbIkpJS0FOX0FQSV9CQVNFX1VSTCIsImdldEN1cnJlbnRTZWFzb25BbmltZSIsImFsbEFuaW1lIiwicGFnZSIsImhhc05leHRQYWdlIiwiZGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZmlsdGVyIiwiYW5pbWUiLCJtYWxfaWQiLCJ0eXBlIiwicGFnaW5hdGlvbiIsImhhc19uZXh0X3BhZ2UiLCJyZW1vdmVEdXBsaWNhdGVBbmltZSIsImFuaW1lTGlzdCIsInNlZW5UaXRsZXMiLCJTZXQiLCJ1bmlxdWVBbmltZSIsInRpdGxlIiwidGl0bGVfamFwYW5lc2UiLCJ0aXRsZV9lbmdsaXNoIiwibm9ybWFsaXplZFRpdGxlIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwiaGFzIiwiYWRkIiwiZ2V0QW5pbWVCeUlkIiwiaWQiLCJjYWNoZSIsImNvbnNvbGUiLCJlcnJvciIsInN0YXR1cyIsImdldEFuaW1lRXh0ZXJuYWxMaW5rcyIsImFuaW1lSWQiLCJvZmZpY2lhbFNpdGUiLCJmaW5kIiwibGluayIsIm5hbWUiLCJpbmNsdWRlcyIsInVybCIsInNvcnRBbmltZUJ5QnJvYWRjYXN0RGF5IiwiZGF5T3JkZXIiLCJzb3J0IiwiYSIsImIiLCJkYXlBIiwiYnJvYWRjYXN0IiwiZGF5IiwiZGF5QiIsImluZGV4QSIsImluZGV4T2YiLCJpbmRleEIiLCJ0eXBlQSIsInR5cGVCIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/jikan-api.ts\n"));

/***/ })

});